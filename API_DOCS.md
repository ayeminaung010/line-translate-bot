# API Documentation

## Overview

The Line Translate Bot exposes two main endpoints:

1. **Health Check Endpoint** - Basic status check
2. **LINE Webhook Endpoint** - Receives and processes messages from LINE platform
3. **tRPC API** - Type-safe API procedures

---

## Endpoints

### 1. Health Check Endpoint

#### Endpoint
```
GET /
```

#### Description
Simple health check endpoint to verify the server is running and responsive.

#### Request

```bash
curl http://localhost:3000
```

#### Response

**Status Code**: `200 OK`

```json
{
  "message": "OK"
}
```

#### Use Cases
- Deployment health checks
- Monitoring and uptime verification
- Load balancer status checks

---

### 2. LINE Webhook Endpoint

#### Endpoint
```
POST /line-webhook
```

#### Description
Receives webhook events from the LINE Messaging API platform. This endpoint processes incoming messages, translates them to the configured target language using Google Cloud Translation API v2 when available (falling back to Google Gemini), and sends the translated text back to the user.

#### Authentication
The endpoint validates incoming requests using LINE's signature verification mechanism.

**Required Headers**:
- `Content-Type`: `application/json`
- `X-Line-Signature`: HMAC-SHA256 signature (generated by LINE platform)

#### Request

**Content-Type**: `application/json`

**Header**:
```
X-Line-Signature: <signature-hash>
```

**Body** (LINE Webhook Event Format):
```json
{
  "events": [
    {
      "type": "message",
      "message": {
        "type": "text",
        "id": "100001",
        "text": "Hello, how are you?"
      },
      "replyToken": "nHuyWiB7yP5Zw52FIkcQT",
      "source": {
        "type": "user",
        "userId": "U1234567890abcdef1234567890abcdef"
      },
      "timestamp": 1462629479859
    }
  ]
}
```

#### Response

**Status Code**: `200 OK` (Message processed successfully)

```json
{
  "success": true
}
```

**Status Code**: `401 Unauthorized` (Invalid signature)

```
Invalid signature
```

**Status Code**: `500 Internal Server Error` (Processing failed)

```json
{
  "message": "Error description"
}
```

#### Request/Response Flow

```
1. LINE Platform sends webhook POST request
   ↓
2. Server validates X-Line-Signature header
   ├─ Invalid: Return 401 "Invalid signature"
   └─ Valid: Continue
   ↓
3. Parse JSON body to extract events
   ↓
4. For each event:
   ├─ Filter message events (type === 'message' && message.type === 'text')
   ├─ Extract: message.text, event.replyToken
   └─ Call translateText()
   ↓
5. translateText() function:
   ├─ Construct Gemini prompt
   ├─ Call Gemini API with POST request
   ├─ Parse response and extract translated text
   └─ Return translation
   ↓
6. Send reply message via LINE API using replyToken
   ↓
7. Return 200 OK with { "success": true }
```

#### Example: Sending a Message to Translate

User sends message via LINE app → LINE Platform forwards to webhook

**User Message**: "こんにちは" (Japanese: "Hello")

**Webhook Payload**:
```json
{
  "events": [
    {
      "type": "message",
      "message": {
        "type": "text",
        "id": "100001",
        "text": "こんにちは"
      },
      "replyToken": "nHuyWiB7yP5Zw52FIkcQT",
      "source": {
        "type": "user",
        "userId": "U1234567890abcdef1234567890abcdef"
      },
      "timestamp": 1462629479859
    }
  ]
}
```

**Bot Response**: 
The bot translates the message and sends it back to the user via LINE app:
```
Hello
```

#### Event Types Handled

| Event Type | Supported | Behavior |
|------------|-----------|----------|
| `message` (text) | ✅ Yes | Translates and replies |
| `message` (image, video, etc.) | ❌ No | Ignored (no reply) |
| `follow` | ❌ No | Ignored |
| `unfollow` | ❌ No | Ignored |
| `join` | ❌ No | Ignored |
| `leave` | ❌ No | Ignored |
| `postback` | ❌ No | Ignored |
| `beacon` | ❌ No | Ignored |

#### Error Handling

| Error Scenario | Response |
|----------------|----------|
| Invalid webhook signature | Status: 401, Body: `"Invalid signature"` |
| JSON parsing error | Status: 500, Body: `{ "message": "Error details" }` |
| Google Translate daily limit reached | Status: 200 (webhook validated), Bot replies: "⚠️ Daily translation limit reached. Please try again tomorrow!" |
| Gemini API key missing | Status: 200 (webhook validated), Bot replies: "Translation service is currently unavailable." |
| Gemini API unreachable | Status: 200 (webhook validated), Bot replies: "Sorry, I couldn't translate that." |
| Gemini API quota exceeded | Status: 200 (webhook validated), Bot replies: "Sorry, I couldn't translate that." |
| LINE API call fails | Status: 200 (webhook validated), Error logged: "Failed to send reply message" |

#### Rate Limiting

No explicit rate limiting is implemented. Consider adding:
- Per-user message limits
- Per-minute request limits
- Daily API quota tracking

---

### 3. tRPC API Endpoints

#### Overview

tRPC provides type-safe API procedures. Access via HTTP at `/trpc/[procedure]`.

#### Health Check Procedure

**Procedure Name**: `healthCheck`

**Type**: Query (read-only, no side effects)

**HTTP Request**:
```
GET /trpc/healthCheck
```

or

```
POST /trpc/healthCheck
```

**Response**:
```json
{
  "result": {
    "data": "OK"
  }
}
```

**Usage Example (Browser)**:
```
http://localhost:3000/trpc/healthCheck
```

**Usage Example (cURL)**:
```bash
curl http://localhost:3000/trpc/healthCheck
```

**Usage Example (JavaScript Client)**:
```typescript
import { createTRPCProxyClient, httpBatchLink } from '@trpc/client';
import type { AppRouter } from './routers';

const trpc = createTRPCProxyClient<AppRouter>({
  links: [
    httpBatchLink({
      url: 'http://localhost:3000/trpc',
    }),
  ],
});

const result = await trpc.healthCheck.query();
console.log(result); // "OK"
```

#### Future Procedures

The router can be extended with additional procedures for:
- Translation history
- User preferences
- Analytics data
- Admin operations

---

## Webhook Configuration

### Setting Up the Webhook URL in LINE Console

1. Go to [LINE Developers Console](https://developers.line.biz/)
2. Select your channel
3. Go to **Messaging API** tab
4. Find **Webhook URL** setting
5. Enter your endpoint: `https://your-domain.com/line-webhook`
6. Click **Verify** to test the connection
7. Enable **Use webhook**

### Example Webhook URLs

| Environment | URL |
|-------------|-----|
| Development (ngrok) | `https://abc123.ngrok.io/line-webhook` |
| Production (Vercel) | `https://your-bot.vercel.app/line-webhook` |
| Production (Custom domain) | `https://api.your-domain.com/line-webhook` |

---

## Implementation Details

### Translation Prompt

The bot uses the following prompt structure for Gemini API:

```
Translate the following text into English. Provide only the translated text, without any additional explanations or context:

"{user_message}"
```

**Example**:
```
Translate the following text into English. Provide only the translated text, without any additional explanations or context:

"Hola, ¿cómo estás?"
```

**Expected Response**:
```
Hello, how are you?
```

### Google Cloud Translation API Integration

**API Endpoint**:
```
https://translation.googleapis.com/language/translate/v2
```

**Method**: `POST`

**Authentication**: Query parameter `key={GOOGLE_TRANSLATE_API_KEY}`

**Request Format**:
```json
{
  "q": "<text to translate>",
  "target": "<iso-639-1 language code>",
  "format": "text"
}
```

**Response Format**:
```json
{
  "data": {
    "translations": [
      {
        "translatedText": "<translated_text>"
      }
    ]
  }
}
```

**Daily Limit Handling**:
- HTTP `403` responses with `dailyLimitExceeded` reason return the friendly message `⚠️ Daily translation limit reached. Please try again tomorrow!`
- All other errors are logged and return `Sorry, an error occurred.` to the user.

---

### Gemini API Integration

**API Endpoint**:
```
https://generativelanguage.googleapis.com/v1beta/models/{MODEL}:generateContent
```

**Default Model**: `gemini-1.5-flash-latest`

**Configure Model**: Set the `GEMINI_MODEL` environment variable to override the default (for example, `gemini-1.5-pro-latest`).

**Method**: `POST`

**Authentication**: Query parameter `key={GEMINI_API_KEY}`

**Request Format**:
```json
{
  "contents": [
    {
      "role": "user",
      "parts": [
        {
          "text": "<translation_prompt>"
        }
      ]
    }
  ]
}
```

**Response Format**:
```json
{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "<translated_text>"
          }
        ]
      }
    }
  ]
}
```

---

## LINE API Integration

### Reply Message API

The bot uses LINE's Reply Message API to send translations back to users.

**Documentation**: [LINE Reply Message API](https://developers.line.biz/en/reference/messaging-api/#send-reply-message)

**Implementation**:
```typescript
const response = await client.replyMessage({
  replyToken: replyToken,
  messages: [
    {
      type: 'text',
      text: translatedText,
    }
  ],
});
```

### Required Permissions

Your LINE channel requires:
- **Send API** permission
- **Messaging API** enabled

---

## Testing the API

### Test Health Endpoint

```bash
# Via cURL
curl -X GET http://localhost:3000

# Via wget
wget http://localhost:3000

# Via httpie
http GET http://localhost:3000
```

### Test Webhook (Local Development)

1. **Expose local server**:
   ```bash
   ngrok http 3000
   # Returns: Forwarding https://abc123.ngrok.io -> http://localhost:3000
   ```

2. **Update webhook URL** in LINE Developers Console to `https://abc123.ngrok.io/line-webhook`

3. **Send test message** via LINE app

4. **Check logs** in terminal running `npm run dev`

### Test with cURL (Simulating LINE Webhook)

You need to generate a valid HMAC-SHA256 signature. Here's a Node.js script:

```javascript
const crypto = require('crypto');

const channelSecret = 'your_channel_secret';
const body = JSON.stringify({
  events: [{
    type: 'message',
    message: { type: 'text', text: 'Hello' },
    replyToken: 'test_token',
    source: { type: 'user', userId: 'U123' },
    timestamp: Date.now()
  }]
});

const signature = crypto
  .createHmac('sha256', channelSecret)
  .update(body, 'utf8')
  .digest('base64');

console.log('X-Line-Signature:', signature);
console.log('Body:', body);
```

Then use with cURL:
```bash
curl -X POST http://localhost:3000/line-webhook \
  -H "Content-Type: application/json" \
  -H "X-Line-Signature: <generated_signature>" \
  -d '<json_body>'
```

---

## Error Codes & Messages

| Code | Message | Cause | Solution |
|------|---------|-------|----------|
| 401 | Invalid signature | Webhook signature validation failed | Verify `LINE_CHANNEL_SECRET` matches LINE console |
| 500 | Error message varies | Server error during processing | Check logs, verify environment variables |
| 500 | "Unknown error" | Uncaught exception | Check server logs for stack trace |

---

## Rate Limiting & Quotas

### Current Status
- **No rate limiting**: Bot accepts all requests
- **Gemini API**: Subject to Google Cloud quotas

### Recommendations for Production

1. **Implement request throttling**:
   ```typescript
   // Add middleware to limit requests per user
   ```

2. **Add message queue**:
   - Use Redis or similar for handling high volume
   - Prevents overwhelming Gemini API

3. **Cache translations**:
   - Store common phrases
   - Reduce API calls and costs

4. **Monitor quotas**:
   - Set up Google Cloud alerts
   - Monitor Gemini API usage

---

## Security Considerations

### Current Security Measures

✅ **Webhook Signature Validation**
- All requests validated using HMAC-SHA256
- Prevents unauthorized access

### Recommended Enhancements

- [ ] Add rate limiting per user
- [ ] Implement API key authentication for tRPC endpoints
- [ ] Use HTTPS only in production
- [ ] Add request logging/monitoring
- [ ] Implement CORS policies if used from browsers
- [ ] Add input sanitization for translation prompts
- [ ] Store API credentials in secure vault (not .env files)
- [ ] Implement request timeouts

---

## Code Examples

### Using the Webhook Programmatically

**Send a test message to the webhook**:

```typescript
const webhook_url = 'http://localhost:3000/line-webhook';
const channel_secret = 'your_channel_secret';
const test_message = 'Hello, translate me!';

const crypto = require('crypto');

const body = JSON.stringify({
  events: [{
    type: 'message',
    message: { type: 'text', text: test_message },
    replyToken: 'test_token_' + Date.now(),
    source: { type: 'user', userId: 'U_test_user' },
    timestamp: Date.now()
  }]
});

const signature = crypto
  .createHmac('sha256', channel_secret)
  .update(body, 'utf8')
  .digest('base64');

await fetch(webhook_url, {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'X-Line-Signature': signature
  },
  body: body
});
```

### Monitoring the Webhook

**Check webhook response times**:

```bash
time curl -X POST http://localhost:3000/line-webhook \
  -H "Content-Type: application/json" \
  -H "X-Line-Signature: valid_signature" \
  -d '{...webhook_payload...}'
```

---

## FAQ

**Q: How long does translation take?**
A: Typically 500ms-2000ms depending on Gemini API latency.

**Q: Can I translate to languages other than English?**
A: Yes! Edit the `targetLanguage` variable in `translateText()` function.

**Q: What happens if Gemini API is down?**
A: User receives: "Sorry, I couldn't translate that."

**Q: Can the bot handle media messages?**
A: Currently only text messages. Images, videos, etc. are ignored.

**Q: Is there a message queue?**
A: No, messages are processed synchronously. For high volume, add a queue.

**Q: Can I store translation history?**
A: Not currently. Add a database (MongoDB, PostgreSQL) and extend tRPC router.

---

**Last Updated**: January 2026
